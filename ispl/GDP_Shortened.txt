Semantics=SingleAssignment;

Agent Environment
	Vars: 
		r1: 0..3; 
			-- resource r1 is 0 if available and i if agent Ai holds it
		r2: 0..3; 
		r3: 0..3; 
	end Vars
	Actions = {none};
	Protocol: 
		Other: {none}; 
	end Protocol
	Evolution: 
		r1 = 1 if r1 = 0 and A1.Action = req1 and A2.Action != req1 and A3.Action != req1;
			-- if r1 is available and A1 is the only agent that requests it, then A1 will hold r1
		r1 = 0 if r1 = 1 and A1.Action = rel1;
			-- if A1 holds r1 and releases it, then r1 will be available
		r1 = 0 if r1 = 1 and A1.Action = relall;
			-- if A1 holds r1 and releases all resources, then r1 will be available
		...
	end Evolution
end Agent

Agent A1
	Lobsvars = {r1, r2};
		-- agent A1 can observe and access resources r1 and r2
	Vars:
		rem: 0..2;
		-- rem indicates the remaining demand of resources of the agent, it can be maximally 2 which is the total demand
	end Vars
	Actions = {req1, req2, rel1, rel2, relall, idle};
		-- request r1, request r2, release r1, release r2, release all, idle
	Protocol:
		rem = 0 : {relall};
			-- if the remaining demand is 0, then the available action is to release all resources
		rem > 0 : {idle};
			-- if the remaining demand is greater than 0, then the idle action is available
		rem > 0 and Environment.r1 = 0 : {req1};
			-- if the remaining demand is greater than 0 and the resource r1 is available, then the agent can request r1
		rem > 0 and Environment.r1 = 1 : {rel1};
			-- if the remaining demand is greater than 0 and the resource r1 is hold by the agent, then the agent can release r1
		...
	end Protocol
	Evolution:
		rem = rem-1 if action = req1 and Environment.r1 = 0 and A2.Action != req1 and A3.Action != req1;
			-- if A1 is the only agent that requests r1, then the remaining demand of the agent will be decremented
		rem = rem+1 if action = rel1;
			-- if A1 releases r1, then the remaining demand of the agent will be incremented
		...
		rem = 2 if action = relall;
			-- if A1 releases all resources, then the remaining demand of the agent will be set to its total demand, which is 2 for A1
	end Evolution
end Agent

Agent A2
	Lobsvars = {r1, r2, r3};
	Vars:
		rem: 0..2;
	end Vars
	...
end Agent

Agent A3
	Lobsvars = {r3};
	Vars:
		rem: 0..1;
	end Vars
	...
end Agent

InitStates
	Environment.r1=0 and
	Environment.r2=0 and
	Environment.r3=0 and
	A1.rem=2 and
	A2.rem=2 and
	A3.rem=1;
end InitStates
	-- initially all resources are available and the remaining demand of each agent is its total demand

--
-- the remaining part does not belong to the model but is needed for the evaluation of the temporal logic formula
--

Evaluation
	eat1 if A1.rem=0;
		-- eat1 is a predicate that is true when the remaining demand of A1 is 0
	eat2 if A2.rem=0;
	eat3 if A3.rem=0;
end Evaluation

Groups
	A1A2 = {A1,A2};
end Groups
	-- A1A2 describes the coalition of the agents A1 and A2 which can be used in the formula to be checked

Formulae
	<A1A2>G ((<A1A2>F eat1) and (<A1A2>F eat2));
end Formulae
	-- the coalition has a strategy such that globally: the coalition has a strategy that agent A1 eventually eats and the coalition has a strategy that agent A2 eventually eats

--
-- with this operational model, the agents can observe everything except the total demand of the other agents
-- in order to let the agents also observe the total demand of the other agents further variables need to be added to the environment
--
-- so far we do not make use of fairness constraints 
-- a reasonable fairness constraint would be that the agents need to perform a 'non-idle' action infinitely often
-- fairness constraints can only refer to predicates and not to actions, so additional variables/predicates would be required for such a fairness constraint